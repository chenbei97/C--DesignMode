对于工厂模式里边涉及到的类重复一下：
现在有怪物基类和3个怪物子类，即Monster以及UndeadMonster、ElementMonster和MechanicMonster
每个怪物子类有配套的工厂子类，UndeadFactory、ElementFactory、MechanicFactory，均继承自MonsterFactory
工厂基类MonsterFactory有个纯虚函数，createMonster()，每个工厂子类需要重实现

现在假设把工厂创建怪物的能力放在怪物基类中，也就是怪物基类增加1个clone虚函数，可以完全的复制自己
同步的，工厂子类的能力也移动到对应的怪物子类中，这样工厂类全部消失，原型模式无需额外的工厂类，这是一个主要特点

参见Monster.h和3个怪物子类UndeadMonster.h、ElementMonster.h、MechanicMonster.h的定义

原型模式适用于对象内部数据复杂多变时的情况，可以立即创建出相同的对象
如果使用工厂模式，首先需要调用工厂方法createMonster()，然后再通过一些成员函数等设置这个对象的生命值、魔法值以及状态等
这样涉及到的代码很繁琐，而clone方法无需使用这些成员函数，如果clone内部不使用new(*this)借助拷贝构造
实际上clone内部也是借助各种成员函数来对创建的实例属性进行设置
createMonster()方法内部实际还是需要怪物子类的类名来new实现创建，外部来看用户无需知道类名
new(*this)是根据现有对象生成新对象，也可以不知道现有对象所属的类名，是和工厂模式的共同点

体现工厂模式和原型模式的区别还有个例子，假设有个全局函数，其参数类型是Monster*
函数内部需要根据这个参数得到一个怪物子类实例，然后做一些事情，如果Monster没有clone方法
由于Monster是虚类不能实例化，那么就必须借助基类到子类的dynamic_cast转换函数来得到子类实例


--- 快速理解 ---
基类指针指向子类对象,想快速复制一个新对象,必须知道子类对象的类名
基类提供Base* clone()方法,子类return new Derive(),用户就可以直接使用clone无需知道子类是什么类型了