简单工厂模式

假设闯关游戏需要打一些怪物，怪物有3种类型，比如亡灵类、元素类和机械类怪物，后续还会增加其它种类
怪物也具备熟悉，魔法值、生命值和攻击力等，所以可以定义怪物类作为父类，然后派生3个怪物子类
见Monster.h和MonsterSub.h当中的定义

然后主程序可能这样创建和使用3类怪物
UndeadMonster * und = new UndeadMonster(1000,200,300);
ElementMonster * ele = new ElementMonster(1000,200,300);
MechanicMonster * mec = new MechanicMonster(1000,200,300);
delete und;
delete ele;
delete mec;

这样的坏处在于主程序必须要知道具体的怪物类名导致紧耦合
随着以后怪物的种类越来越多，修改任何一个怪物的创建都要修改全局

所以可以引入一个工厂类用于生产不同的怪物，内部可以使用怪物类父指针，
创建时可以动态的指向不同的怪物子类，可见MonsterFactory.h定义
这样main.cpp就无需再面对各种具体的怪物类，只需要面对MonsterFactory即可
起始就是减少主程序的代码，增加了类的代码，类是可拓展的可以修改的，主程序不好修改

简单工厂方法的问题是在于怪物种类多了以后，switch分支就会变多，不利于维护
同时违反了开放-封闭原则，所谓开放是对扩展开放，封闭是对修改封闭
即尽可能不通过修改原有函数来拓展功能，而是通过增加新类和新成员函数来拓展

createMonster()函数可以声明为静态的，这样主程序使用时无需再创建工厂对象，可以直接使用成员函数
这也是所谓的静态工厂模式


