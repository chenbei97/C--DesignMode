单例模式适用于全局只有一个静态对象的，例如日志系统，线程池、文件管理系统等都应该是唯一的

单例模式是私有化构造函数、拷贝构造函数、operator=函数以及析构函数
析构函数是防止全局对象被外界随意删除，定义在Singleton.h中

V1版本: 这个版本的问题是多线程下可能造成多次创建静态实例的问题
        线程1，正在执行"if (mLogConfig == nullptr)"的判断并成功进入
        此时切换到线程2，也是执行"if (mLogConfig == nullptr)"并成功进入
        然后创建出1个实例，紧接着回到线程1，又创建了1个实例
V2版本: 加锁，下个线程必须等待上个线程执行完，但是多线程频繁的调用实例时资源消耗过大
        另外，一旦实例被创建，"if (mLogConfig == nullptr)"的判断不会成功，相当于是只读的返回一个地址
        这样加锁变得浪费也没有意义
V3版本: 双重判断，第一层判断"if (mLogConfig == nullptr)"进入以后才加锁，如果if不满足直接返回只读对象避免频繁加锁
        进入第一层判断后，不保证实例尚未创建，很可能其他线程已被创建，所以进入第一层判断才加锁
        加锁之后再次判断"if (mLogConfig == nullptr)"，如果确实没被创建，才创建，否则直接返回
        这个版本仍然存在问题: 
            由于编译器的优化机制————内存访问重新排序机制
            简单来说，正常的初始化操作是先malloc分配内存，然后构造初始化内存，再用实例指针指向它
            编译器可能分配完内存，并不调用构造函数，而是让指针先执向它，再构造初始化
            另外编译器很可能直接进入第2层if的判断，而不是从第1层
            这样，线程1进入第2层测试满足条件，然后内存被分配但尚未初始化，此时线程2进入"if (mLogConfig == nullptr)"第2层判断
            判断不成立所以直接返回一个尚未构造初始化的内存地址
V4版本: 一个解决双重判断失效的可能方案,禁止内存重排序即可
V5版本: 饿汉式,实例化静态变量时直接创建对象而不是赋值nullptr,早于main函数的执行就被创建,不再受多线程问题困扰
        懒汉式,V1-V5,初始化时机被延后,避免过早消耗内存资源
V6版本: 基于V1增加1个成员函数,静态实例的内存释放,用户需要手工调用
V7版本: 基于V5增加1个嵌套类,静态实例的内存释放自动调用(饿汉式) 定义了静态嵌套类成员
V8版本: 基于V1增加1个嵌套类,静态实例的内存释放自动调用(懒汉式) 定义局部静态对象即可
V9版本: 直接定义静态对象而非指针类型,本质上也属于懒汉模式,其问题在于外部使用全局变量来引用该静态对象时可能存在初始化的先后问题
        int global_v = LogConfig::getInstance()->lineCount(); // global_v可能先于LogConfig::getInstance()初始化
        这样导致global_v被初始化时引用的是尚未初始化的LogConfig::getInstance()
VA版本: 返回局部静态变量的引用，Class类型的局部静态变量首次调用时才初始化，Basic类型的局部静态变量在编译时就已经确定
        static LogConfig& getInstance()
        {
            static LogConfig instance; // 首次调用getInstance()函数才会初始化
            return instance;
        }
        int func()
        {
            static int sti = 100; // 编译阶段就进行了常量初始化,无需调用func()sti的值就已经确定为100
            sti += 80;
            return sti;
        }
        此版本也存在多线程问题，在创建任何其他线程之前，事先调用"LogConfig::getInstance();"创建出对象,就不会再有问题

最后是2个单例模式类之间的互相引用问题，假设还有个游戏配置类GameConfig也实例化了1个静态对象
但是游戏类析构函数为了记录一些游戏信息使用到了LogConfig类，但是2个类静态实例释放的先后顺序不是能控制的
所以，解决这个问题的方法是：不要在单例类的析构函数中引用其它单例类对象


